import cv2
import numpy
import math
from enum import Enum

class GripPipeline:
    # An OpenCV pipeline generated by GRIP and improved by Owen et al.

    def __init__(self):
        # initializes all values to presets or None if need to be set

        self.BlurType = Enum('BlurType', 'Box_Blur Gaussian_Blur Median_Filter Bilateral_Filter')

        # Resize parameters
        self.RESIZE_WIDTH = 320.0
        self.RESIZE_HEIGHT = 240
        self.RESIZE_INTERPOLATION = cv2.INTER_CUBIC

        # Blur parameters
        self.BLUR_TYPE = self.BlurType.Box_Blur
        self.BLUR_RADIUS = 5.405405405405399

        # HSL threshold parameters
        self.HSL_HUE = [118.16546762589928, 150.96774193548387]
        self.HSL_SAT = [52.74280575539568, 255.0]
        self.HSL_LUM = [0.0, 255.0]

        # Find contours parameter
        self.FIND_ONLY_EXTERNAL = False

        # Filter contours parameters
        self.FILTER_MIN_AREA = 50.0
        self.FILTER_MIN_PERIMETER = 0.0
        self.FILTER_MIN_WIDTH = 0.0
        self.FILTER_MAX_WIDTH = 1000.0
        self.FILTER_MIN_HEIGHT = 0.0
        self.FILTER_MAX_HEIGHT = 1000.0
        self.FILTER_SOLIDITY = [80.93525179856115, 100.0]
        self.FILTER_MAX_VERTICES = 1000000.0
        self.FILTER_MIN_VERTICES = 0.0
        self.FILTER_MIN_RATIO = 0.5
        self.FILTER_MAX_RATIO = 1.5

    def process(self, source0):
        # Runs the pipeline and sets all outputs to new values.

        results = self.convex_hulls(self.filter_contours(
            self.find_contours(self.hsl_threshold(self.blur(self.resize_image(source0))))))

    @staticmethod
    def resize_image(self, input):
        """Scales and image to an exact size.
        Args:
            input: A numpy.ndarray.
        Returns:
            A numpy.ndarray of the new size.
        """
        return cv2.resize(input, ((int)(self.RESIZE_WIDTH), (int)(self.RESIZE_HEIGHT)), 0, 0, self.RESIZE_INTERPOLATION)

    @staticmethod
    def blur(self, src):
        """Softens an image using one of several filters.
        Args:
            src: The source mat (numpy.ndarray).
            type: The blurType to perform represented as an int.
            radius: The radius for the blur as a float.
        Returns:
            A numpy.ndarray that has been blurred.
        """
        if(type is self.BlurType.Box_Blur):
            ksize = int(2 * round(self.BLUR_RADIUS) + 1)
            return cv2.blur(src, (ksize, ksize))
        elif(type is self.BlurType.Gaussian_Blur):
            ksize = int(6 * round(self.BLUR_RADIUS) + 1)
            return cv2.GaussianBlur(src, (ksize, ksize), round(self.BLUR_RADIUS))
        elif(type is self.BlurType.Median_Filter):
            ksize = int(2 * round(self.BLUR_RADIUS) + 1)
            return cv2.medianBlur(src, ksize)
        else:
            return cv2.bilateralFilter(src, -1, round(self.BLUR_RADIUS), round(self.BLUR_RADIUS))

    @staticmethod
    def hsl_threshold(self, input):
        """Segment an image based on hue, saturation, and luminance ranges.
        Args:
            input: A BGR numpy.ndarray.
        Returns:
            A black and white numpy.ndarray.
        """
        out = cv2.cvtColor(input, cv2.COLOR_BGR2HLS)
        return cv2.inRange(out, (self.HSL_HUE[0], self.HSL_LUM[0], self.HSL_SAT[0]),  (self.HSL_HUE[1], self.HSL_LUM[1], self.HSL_SAT[1]))

    @staticmethod
    def find_contours(self, input):
        """Sets the values of pixels in a binary image to their distance to the nearest black pixel.
        Args:
            input: A numpy.ndarray.
        Return:
            A list of numpy.ndarray where each one represents a contour.
        """
        if(self.FILTER_ONLY_EXTERNAL):
            mode = cv2.RETR_EXTERNAL
        else:
            mode = cv2.RETR_LIST
        method = cv2.CHAIN_APPROX_SIMPLE
        im2, contours, hierarchy =cv2.findContours(input, mode=mode, method=method)
        return contours

    @staticmethod
    def filter_contours(self, input_contours):
        """Filters out contours that do not meet certain criteria.
        Args:
            input_contours: Contours as a list of numpy.ndarray.
        Returns:
            Contours as a list of numpy.ndarray.
        """
        output = []
        for contour in input_contours:
            x,y,w,h = cv2.boundingRect(contour)
            if (w < self.FILTER_MIN_WIDTH or w > self.FILTER_MAX_WIDTH):
                continue
            if (h < self.FILTER_MIN_HEIGHT or h > self.FILTER_MAX_HEIGHT):
                continue
            area = cv2.contourArea(contour)
            if (area < self.FILTER_MIN_AREA):
                continue
            if (cv2.arcLength(contour, True) < self.FILTER_MIN_PERIMETER):
                continue
            hull = cv2.convexHull(contour)
            solid = 100 * area / cv2.contourArea(hull)
            if (solid < self.FILTER_SOLIDITY[0] or solid > self.FILTER_SOLIDITY[1]):
                continue
            if (len(contour) < self.FILTER_MIN_VERTEX_COUNT or len(contour) > self.FILTER_MAX_VERTEX_COUNT):
                continue
            ratio = (float)(w) / h
            if (ratio < self.FILTER_MIN_RATIO or ratio > self.FILTER_MAX_RATIO):
                continue
            output.append(contour)
        return output

    @staticmethod
    def convex_hulls(input_contours):
        """Computes the convex hulls of contours.
        Args:
            input_contours: A list of numpy.ndarray that each represent a contour.
        Returns:
            A list of numpy.ndarray that each represent a contour.
        """
        output = []
        for contour in input_contours:
            output.append(cv2.convexHull(contour))
        return output
